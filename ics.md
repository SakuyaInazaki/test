# 总结
1.所有相反数都是原数取反再+1
2.有符号右移是算术右移，在左边用最高有效位（即符号位）的值进行覆盖；无符号是逻辑右移，单纯/2。但是左移只有逻辑左移，用0覆盖
3.N位补码系统

比如8位补码系统可以表示
-128/-127~0/1~127

对于最小的负数：1000 0000，其相反数为0111 1111+1=1000 0000。说明它无法取到对应的相反数，造成溢出。

4.-x=~x+1
5.1字节=8位，32/64位操作系统是位宽
6.x86-64使用小端进行寻址
7.选择1字节(8位)作为最小可寻址单位
8.1字节是存储单个字符（ASCII 码）所需的最小标准单位
9.小端大端只在存数据时候使用，小端按照最低有效字节在前面的方式。
10.存整数和存字符串是不同的，存字符串时候的数存的是ascii码，字符串结尾有0x00。
11.0^x=x，^具有交换律，x^x=0。
12.x^(~0)=~x
13.移动超过位宽时会取模，如移动36位时会移动36%32位即4位。
14.补码最高位有权值
原码最高位纯是符号位，有正0和-0（0000 0000，1000 0000）
反码：正数反码是自身，负数的反码是对其正数形式进行取反，有正0和负0（0000 0000，1111 1111）
15.强制类型转换的结果保持位值不变，只是改变了解释这些位的方式
16.扩展有符号数字应该在前面补最高位
17.截断补码就直接扔掉，重新解释
#TODO：整数的运算